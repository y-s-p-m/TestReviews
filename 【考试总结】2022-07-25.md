# 梦符

考虑相交的条件： $Ql\le a\le Qr,Qu\le r,Qv\ge l$ 。那么求出来 $l\le Qv$ 的所有线段和并减去 $r<Qu$ 的线段权值之和即可

使用可持久化线段树

# 大合葬

将 $a_i$ 对位减 $b_i$ 并将问题转化为求使用 $A_{2,*},A_{3,*}$ 将序列清零的最小步数。令 $A=A_{2,1}-A_{2,2},B=A_{3,1}-A_{3,2}$。再设对序列第 $i$ 为进行的 $\pm A$ 操作次数为 $cA_i$ 的绝对值，为负则表示操作为 $-A$。

**注意到任意一组 $\{cA,cB\}$ 在满足 $\sum cA_i=0$ 时都可以还原一个操作序列**，那么对于每个 $i$ 使用 exgcd 求出来 $A\times cA_i+B\times cB_i=a_i$ 的满足 $|cA_i|+|cB_i|$ 最小的解，可以取 $cA,cB$ 之一在取正/负 绝对值最小 的四个情况。

此时可能 $\sum cA_i\neq 0$ ，使用小根堆进行调整即可。以 $\sum cA_i<0$ 为例，需要找若干 $i$ 让 $cA_i\leftarrow cA_i+B,cB_i\leftarrow cB_i-A$ ，每次找到最小增量者贪心，弹出堆并将其在进行增加时的增量入堆。

# 白楼剑

赛时做法大概是扫描线，然后暴跳后缀树，每个点最长长度乘出现次数的贡献用树状数组维护，节点内部的等差数列写个李超线段树做做

标算是回滚莫队，从左向右的扩展做法和上面一致，匹配到的节点特别处理，否则是根链 $len\times siz$ 最大值，可以预处理。完成向右扩展之后向左扩展，在反串 $\rm SAM$ 上做一样的事情就行了。

乍一看左指针每挪一下要倍增一次，不过右指针挪可以在 $\rm SAM$ 上走，而左指针也是在最开始挪的时候倍增一下，一共 $Q$ 次