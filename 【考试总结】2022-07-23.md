# fft

先考察 $mid$ 的取值。结论是将 $[0,n]$ 分成 $[0,2^{\rm highbit(n)})$ 和 $[0,n-2^{\rm highbit(n)})$ 两个部分。这是出于要尽量减少 $2^{p}>n$ 的情况，严谨证明需要归纳

那么可以直接得到 $\rm FFT(n)$ 的基于二进制拆分的表达式，对于每个 $1$ 需要考虑其被消去后的贡献以及消去时 $\rm FFT$ 的代价，注意最后一个 $1$ 做 $\rm FFT$ 上来就是 $p2^p[2^p=n]$ 那么多出来的贡献需要最后减掉

使用 `std::set` 来维护全 $1$ 连续段，处理进位退位本质上都是翻转线段，每个线段的贡献是等差或者二阶等差数列乘等比数列求和，做和式变换可以得到前缀和的简单形式。

# sort

当数组中只有 $0/1$ 时可以通过状压 $\rm DP$ 来计算，即设 $f_S$ 表示处于状态 $S$ 的概率。转移乍一看需要 $2^n$，但是可以逐位计算，枚举当前交换的位并直接继承上一位转移后的结果。

回到本题，使用 $\displaystyle x=\sum_{i=1}^x 1$ 的技巧，枚举 $1\sim n$ 中的每个权值，将 $\ge $ 之的元素置 $1$ 否则置零记作状态，对 $n$ 个状态一起做上面的状压 $\rm DP$

需要做 $m$ 次，时间复杂度 $\Theta(nm2^n)$

# sssp

设 $f_{a,x,y,K}$ 表示从 $x\to y$ 的路径上经过 $a$ 条边的第 $K$ 小路径，使用类似 $\rm Floyd$ 的思想转移使得每条路径都在路径上最大标号处被合并一次得到。

考察第 $2,3$ 维发现转移是矩阵乘法形式，而对于第一维可以倍增，此时加速矩阵乘法时的信息处理即可

将被乘矩阵转置，此时对于矩阵乘法结果 $C_{i,j}[15]$ 而言只需要合并左矩阵第 $i$ 行和右矩阵第 $j$ 行上的信息，实际含义就是这两行上的 $n$ 个元素作为转移点。

合并时现将 $A_{i,k,0}+B^T_{j,k,0}$ 线性建堆（笛卡尔树），之后进行 $k$ 次取出小根堆对顶作为答案，取出的本质上时四元组 (长度，中转点，左路径排名，右路径排名)，每次都将最后一维加一入堆（在最后一维 $\le K$ 时），最后一维是 $0$ 时将第三维加一入堆。

询问显然要向量乘矩阵。
